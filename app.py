# -*- coding: utf-8 -*-
"""App

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/154bLX3EwftGSsAFMJr4s3Vvmc0wDDBPF
"""

import plotly.graph_objects as go
import plotly.express as px
import streamlit as st
import pandas as pd

st.set_page_config(
    page_title="Inclusi√≥n Financiera en Latinoam√©rica",
    page_icon="üìà",
    layout="wide",
    initial_sidebar_state="expanded"
)

selected_palette = {
    "top_bar_color": "#081629",
    "sidebar_bg_color": "#0D2740",
    "main_bg_color": "#0B1F33",
    "button_color": "#1565C0",
    "text_color": "#F5F7FA",
    "header_color": "#F5F7FA",
}

# Cargar estilos base desde styles.css
with open("/content/styles1.css") as css_file:
    st.markdown(f"<style>{css_file.read()}</style>", unsafe_allow_html=True)

# Inyectar variables CSS con la paleta seleccionada
st.markdown(
    f"""
    <style>
    :root {{
        --top-bar-color: {selected_palette["top_bar_color"]};
        --sidebar-bg-color: {selected_palette["sidebar_bg_color"]};
        --main-bg-color: {selected_palette["main_bg_color"]};
        --button-color: {selected_palette["button_color"]};
        --text-color: {selected_palette["text_color"]};
        --header-color: {selected_palette["header_color"]};
    }}
    </style>
    """,
    unsafe_allow_html=True
)

# Cargar datos con cach√© y prepararlos
@st.cache_data
def load():
    df = pd.read_csv("/content/fin.csv", sep=";", encoding="utf-8")
    cols_pct = [
        "account",
        "fiaccount",
        "borrow_money",
        "saved fo old age",
        "borrowed from fam and fri",
        "envio remesa nacional",
        "recibio_remesa_nacional",
        "recibio_remesa_digital",
        "recibio_transferencia_gobierno",
        "recibio_pension_publica",
        "retiro_dinero_cuenta",
        "cuenta_inactiva",
        "pagos_comercio_digital",
        "ahorro_total",
    ]

    for c in cols_pct:
        if c in df.columns:
            df[c] = pd.to_numeric(df[c], errors="coerce") / 1_000_000_000
    return df

# Cargar y preparar datos en la aplicaci√≥n
try:
    df = load()
    st.badge(f"‚úÖ Datos cargados: {len(df)} registros", icon=":material/check:", color="green")
except Exception as e:
    st.error(f"Error al cargar los datos: {e}")
    st.stop()

# Aqu√≠ puedes a√±adir el resto de la l√≥gica de tu aplicaci√≥n Streamlit
st.title("üìä Dashboard de Inclusi√≥n Financiera")
st.dataframe(df.head())


st.markdown("<hr style='border: 1px solid white;'>", unsafe_allow_html=True)

# Brecha de g√©nero (Hombres ‚Äì Mujeres)
h = df[(df["group"]=="gender") & (df["group2"]=="men")]["account"].mean()
m = df[(df["group"]=="gender") & (df["group2"]=="women")]["account"].mean()

st.header("üìå M√©tricas Principales")
met_col1, met_col2, met_col3, met_col4 = st.columns(4)
with met_col1:
  adultos_cuenta   = df["account"].mean() * 100
  st.metric("üë• Adultos con cuenta (%)", f"{adultos_cuenta:.1f}%")

with met_col2:
  brecha_genero = (h - m) * 100 if pd.notna(h) and pd.notna(m) else None
  if brecha_genero is not None:
    st.metric("‚öñÔ∏è Brecha de g√©nero (p.p.)", f"{brecha_genero:.1f}")
  else:
    st.metric("‚öñÔ∏è Brecha de g√©nero (p.p.)", "‚Äî")

with met_col3:
  uso_digital= df["mobileaccount"].dropna().mean() * 100
  if uso_digital is not None:
    st.metric("üì± Uso digital (%)", f"{uso_digital:.2f}%")
  else:
    st.metric("üì± Uso digital (%)", "‚Äî")

with met_col4:
  ahorro_promedio  = df["ahorro_total"].mean() * 100 if "ahorro_total" in df.columns else None
  if ahorro_promedio is not None:
    st.metric("üí∞ Ahorro promedio (%)", f"{ahorro_promedio:.1f}%")
  else:
    st.metric("üí∞ Ahorro promedio (%)", "‚Äî")

st.markdown("<hr style='border: 1px solid white;'>", unsafe_allow_html=True)

tab1, tab2, tab3, tab4 = st.tabs([
    "üìà Evoluci√≥n en el tiempo",
    "üó∫Ô∏è An√°lisis geogr√°fico",
    "üèÖ Top pa√≠ses",
    "üíº Segmentos"
])

with tab1:
    st.subheader("üìà Evoluci√≥n de la inclusi√≥n financiera en el tiempo")

    metric_map = {
        "Adultos con cuenta (%)": "account",
        "Cuenta m√≥vil (%)": "mobileaccount",
        "Ahorro total (%)": "ahorro_total",
        "Pr√©stamo de dinero (%)": "borrow_money",
    }

    time_map = {
        "A√±o": "year"
    }

    col_time, col_metric = st.columns(2)

    with col_time:
        time_grouping = st.selectbox(
            "Agrupar por",
            ["A√±o"],
            key="time_grouping_inc"
        )

    with col_metric:
        metric_type = st.selectbox(
            "M√©trica",
            list(metric_map.keys()),
            key="metric_type_inc"
        )

    sort_time_met = metric_map[metric_type]
    sort_time_gro = time_map[time_grouping]

    df_time = (
        df
        .groupby(sort_time_gro)[list(metric_map.values())]
        .mean()
        .reset_index()
        .sort_values(sort_time_gro)
    )

    df_time[sort_time_met] = df_time[sort_time_met] * 100

    fig_time = px.line(
        df_time,
        x=sort_time_gro,
        y=sort_time_met,
        title=f"Evoluci√≥n de {metric_type} por {time_grouping}",
        markers=True
    )

    fig_time.update_traces(line_width=3)
    fig_time.update_layout(
        hovermode="x unified",
        xaxis_title=time_grouping,
        yaxis_title=metric_type
    )

    fig_time.update_traces(
    line_width=3,
    line_color="#F5F7FA",   # blanco para linea de la grafica
)
    fig_time.update_layout(
    paper_bgcolor="rgba(0,0,0,0)",  # fondo externo transparente
    plot_bgcolor="#0D2740",         # fondo del √°rea de la gr√°fica azul
    font_color="#F5F7FA",           # texto blanco

    title_font=dict(size=20, color="#F5F7FA")
)

    st.plotly_chart(fig_time, use_container_width=True)

# ================== TAB 2: An√°lisis geogr√°fico ================== #
with tab2:
    st.subheader("üó∫Ô∏è An√°lisis geogr√°fico de la inclusi√≥n financiera")

    geo_map = {
        "Pa√≠s": "countrynewwb",
        "Grupo de ingreso": "incomegroup",
    }

    geo_metric_map = {
        "Adultos con cuenta (%)": "account",
        "Cuenta en instituci√≥n financiera (%)": "fiaccount",
        "Cuenta m√≥vil (%)": "mobileaccount",
        "Ahorro total (%)": "ahorro_total",
        "Pr√©stamo de dinero (%)": "borrow_money",
        "Pagos digitales (%)": "pagos_comercio_digital",
    }

    geo_col1, geo_col2 = st.columns(2)

    with geo_col1:
        geo_level_label = st.selectbox(
            "Nivel geogr√°fico",
            list(geo_map.keys()),
            key="geo_level_inc"
        )

    with geo_col2:
        geo_metric_label = st.selectbox(
            "M√©trica",
            list(geo_metric_map.keys()),
            key="geo_metric_inc"
        )

    geo_level_col = geo_map[geo_level_label]
    geo_metric_col = geo_metric_map[geo_metric_label]

    df_geo = (
        df
        .groupby(geo_level_col)[geo_metric_col]
        .mean()
        .reset_index()
        .sort_values(geo_metric_col, ascending=False)
    )

    df_geo[geo_metric_col] = df_geo[geo_metric_col] * 100

    fig_geo = px.bar(
        df_geo,
        x=geo_level_col,
        y=geo_metric_col,
        title=f"{geo_metric_label} por {geo_level_label}",
        color=geo_metric_col,
        color_continuous_scale=["#E3F2FD", "#64B5F6", "#0D47A1"]
    )

    fig_geo.update_layout(
        xaxis_tickangle=-45,
        xaxis_title=geo_level_label,
        yaxis_title=geo_metric_label,
        coloraxis_colorbar_title=geo_metric_label,
        paper_bgcolor="rgba(0,0,0,0)",  # transparente fuera del plot
        plot_bgcolor="#0D2740",         # fondo del √°rea de la gr√°fica
        font_color="#F5F7FA",
        xaxis=dict(
            showgrid=False
        ),
        yaxis=dict(
            showgrid=True,
            gridcolor="rgba(255,255,255,0.08)"
        ),
        title_font=dict(size=20, color="#F5F7FA")
    )

    st.plotly_chart(fig_geo, use_container_width=True)

    st.markdown(f"### üåé Mapa de {geo_metric_label} por pa√≠s")

    df_map = (
        df.groupby("codewb")[geo_metric_col]
        .mean()
        .reset_index()
    )
    df_map[geo_metric_col] *= 100
    df_map.rename(columns={"codewb": "iso3"}, inplace=True)

    fig_map = px.choropleth(
        df_map,
        locations="iso3",
        color=geo_metric_col,
        hover_name="iso3",
        color_continuous_scale=["#E3F2FD", "#64B5F6", "#0D47A1"],
        projection="natural earth",
        labels={geo_metric_col: geo_metric_label},
    )

    fig_map.update_layout(
        geo=dict(
            scope="world",        # muestra todo; si quieres, luego afinamos a solo LatAm
            showframe=False,
            showcountries=True,
            bgcolor="rgba(0,0,0,0)"
        ),
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        font_color="#F5F7FA",
        coloraxis_colorbar_title="Adultos con cuenta (%)"
    )

    st.plotly_chart(fig_map, use_container_width=True)

# ================== TAB 3: Top pa√≠ses ================== #
with tab3:
    st.subheader("üèÖ Top pa√≠ses por inclusi√≥n financiera")

    metric_country_map = {
        "Adultos con cuenta (%)": "account",
        "Cuenta m√≥vil (%)": "mobileaccount",
        "Ahorro total (%)": "ahorro_total",
        "Pr√©stamo de dinero (%)": "borrow_money",
        "Pagos digitales (%)": "pagos_comercio_digital",
        "Cuenta inactiva (%)": "cuenta_inactiva",
    }

    gra2_col1, gra2_col2 = st.columns(2)

    with gra2_col1:
        top_n_countries = st.slider(
            "Selecciona cu√°ntos pa√≠ses mostrar (Top N)",
            min_value=5,
            max_value=25,
            value=10,
            step=1
        )

    with gra2_col2:
        country_metric_label = st.selectbox(
            "Ordenar por",
            list(metric_country_map.keys()),
            key="country_metric_top"
        )

    country_metric_col = metric_country_map[country_metric_label]

    df_countries = (
        df
        .groupby("countrynewwb")[country_metric_col]
        .mean()
        .reset_index()
        .sort_values(country_metric_col, ascending=False)
        .head(top_n_countries)
    )

    df_countries[country_metric_col] = df_countries[country_metric_col] * 100

    fig_countries = px.bar(
        df_countries,
        y="countrynewwb",
        x=country_metric_col,
        orientation="h",
        title=f"Top {top_n_countries} pa√≠ses en {country_metric_label}",
        color=country_metric_col,
        color_continuous_scale=["#E3F2FD", "#64B5F6", "#0D47A1"]
    )

    fig_countries.update_layout(
        yaxis={"categoryorder": "total ascending"},
        xaxis_title=country_metric_label,
        yaxis_title="Pa√≠s",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="#0D2740",
        font_color="#F5F7FA",
        title_font=dict(size=20, color="#F5F7FA")
    )

    st.plotly_chart(fig_countries, use_container_width=True)

# ================== TAB 4: Segmentos ================== #
with tab4:
    st.subheader("üíº An√°lisis por segmento")

    segment_map = {
        "G√©nero": "gender",
        "Nivel educativo": "education",
        "Nivel de ingreso": "income",
        "Zona urbano/rural": "urbanicity",
        "Situaci√≥n laboral": "laborforce"
    }

    segment_label = st.selectbox(
        "Selecciona el tipo de segmento",
        list(segment_map.keys()),
        key="segment_type"
    )

    segment_group = segment_map[segment_label]

    df_segment = df[df["group"] == segment_group].copy()

    if df_segment.empty:
        st.info(f"No hay datos para el segmento: {segment_label}")
    else:
        df_seg_agg = (
            df_segment
            .groupby("group2")[["account", "ahorro_total"]]
            .mean()
            .reset_index()
        )

        df_seg_agg["account"] = df_seg_agg["account"] * 100
        df_seg_agg["ahorro_total"] = df_seg_agg["ahorro_total"] * 100

        gra3_col1, gra3_col2 = st.columns(2)

        pie_colors = ["#E3F2FD", "#90CAF9", "#64B5F6", "#1976D2", "#0D47A1"]

        with gra3_col1:
            fig_seg_account = px.pie(
                df_seg_agg,
                values="account",
                names="group2",
                title=f"Distribuci√≥n de adultos con cuenta por {segment_label}",
                hole=0.4,
                color_discrete_sequence=pie_colors
            )
            fig_seg_account.update_layout(
                paper_bgcolor="rgba(0,0,0,0)",
                plot_bgcolor="#0D2740",
                font_color="#F5F7FA",
                title_font=dict(size=20, color="#F5F7FA"),
                legend=dict(font=dict(color="#F5F7FA"))
            )
            st.plotly_chart(fig_seg_account, use_container_width=True)

        with gra3_col2:
            fig_seg_ahorro = px.pie(
                df_seg_agg,
                values="ahorro_total",
                names="group2",
                title=f"Distribuci√≥n de ahorro total por {segment_label}",
                hole=0.4,
                color_discrete_sequence=pie_colors
            )
            fig_seg_ahorro.update_layout(
                paper_bgcolor="rgba(0,0,0,0)",
                plot_bgcolor="#0D2740",
                font_color="#F5F7FA",
                title_font=dict(size=20, color="#F5F7FA"),
                legend=dict(font=dict(color="#F5F7FA"))
            )
            st.plotly_chart(fig_seg_ahorro, use_container_width=True)